<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mega Tic-Tac-Toe</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        .game-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            max-width: 600px;
            width: 100%;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .title {
            font-size: 2.5em;
            color: #667eea;
            margin-bottom: 10px;
            font-weight: bold;
        }

        .mode-selector {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            justify-content: center;
        }

        .mode-btn {
            padding: 15px 30px;
            border: none;
            border-radius: 10px;
            background: #f0f0f0;
            color: #333;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .mode-btn.active {
            background: #667eea;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .mode-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
        }

        .ai-settings {
            display: none;
            text-align: center;
            margin-bottom: 20px;
            padding: 20px;
            background: #f8f9ff;
            border-radius: 10px;
        }

        .ai-settings.show {
            display: block;
            animation: slideDown 0.3s ease;
        }

        @keyframes slideDown {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .difficulty-selector {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 10px;
        }

        .difficulty-btn {
            padding: 10px 20px;
            border: 2px solid #667eea;
            border-radius: 8px;
            background: white;
            color: #667eea;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .difficulty-btn.active {
            background: #667eea;
            color: white;
        }

        .difficulty-btn:hover {
            background: #667eea;
            color: white;
        }

        .game-status {
            text-align: center;
            margin-bottom: 20px;
            font-size: 18px;
            font-weight: bold;
            color: #333;
            min-height: 25px;
        }

        .player-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9ff;
            border-radius: 10px;
        }

        .player {
            text-align: center;
            flex: 1;
        }

        .player.current {
            background: #667eea;
            color: white;
            border-radius: 8px;
            padding: 10px;
        }

        .mega-board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 8px;
            background: #333;
            padding: 8px;
            border-radius: 15px;
            margin-bottom: 20px;
            aspect-ratio: 1;
            max-width: 450px;
            margin-left: auto;
            margin-right: auto;
        }

        .mini-board {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 2px;
            background: #666;
            padding: 4px;
            border-radius: 8px;
            position: relative;
        }

        .mini-board.active {
            background: #667eea;
            box-shadow: 0 0 20px rgba(102, 126, 234, 0.5);
        }

        .mini-board.won {
            background: #999;
        }

        .mini-board.won::after {
            content: attr(data-winner);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2em;
            font-weight: bold;
            color: #333;
            z-index: 10;
        }

        .cell {
            background: white;
            border: none;
            border-radius: 4px;
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .cell:hover:not(.disabled) {
            background: #f0f0f0;
            transform: scale(1.05);
        }

        .cell.x {
            color: #e74c3c;
            background: #ffeaea;
        }

        .cell.o {
            color: #3498db;
            background: #eaf4ff;
        }

        .cell.disabled {
            cursor: not-allowed;
            opacity: 0.6;
        }

        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
        }

        .control-btn {
            padding: 12px 25px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .new-game-btn {
            background: #2ecc71;
            color: white;
        }

        .new-game-btn:hover {
            background: #27ae60;
            transform: translateY(-2px);
        }

        .rules-btn {
            background: #f39c12;
            color: white;
        }

        .rules-btn:hover {
            background: #e67e22;
            transform: translateY(-2px);
        }

        /* Mobile Responsive */
        @media (max-width: 600px) {
            .game-container {
                padding: 20px;
                margin: 10px;
            }

            .title {
                font-size: 2em;
            }

            .mode-selector {
                flex-direction: column;
                align-items: center;
            }

            .difficulty-selector {
                flex-wrap: wrap;
            }

            .player-info {
                flex-direction: column;
                gap: 10px;
            }

            .controls {
                flex-direction: column;
                align-items: center;
            }
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 15px;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
        }

        .modal-close {
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: #999;
        }

        .modal-close:hover {
            color: #333;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="header">
            <h1 class="title">‚ö° MEGA TIC-TAC-TOE</h1>
            
            <!-- Game Mode Selection -->
            <div class="mode-selector">
                <button class="mode-btn active" onclick="setGameMode('human')">
                    üë• 2 Players
                </button>
                <button class="mode-btn" onclick="setGameMode('ai')">
                    ü§ñ vs AI
                </button>
            </div>

            <!-- AI Settings -->
            <div class="ai-settings" id="ai-settings">
                <h3>üéØ AI Difficulty</h3>
                <div class="difficulty-selector">
                    <button class="difficulty-btn" onclick="setDifficulty('easy')">Easy</button>
                    <button class="difficulty-btn active" onclick="setDifficulty('medium')">Medium</button>
                    <button class="difficulty-btn" onclick="setDifficulty('hard')">Hard</button>
                </div>
            </div>
        </div>

        <!-- Game Status -->
        <div class="game-status" id="game-status">
            Choose any cell to start your mega battle!
        </div>

        <!-- Player Information -->
        <div class="player-info">
            <div class="player current" id="player-x">
                <div style="font-size: 1.5em;">‚ùå</div>
                <div id="player-x-name">Player X</div>
            </div>
            <div style="font-size: 1.2em; align-self: center; font-weight: bold;">VS</div>
            <div class="player" id="player-o">
                <div style="font-size: 1.5em;">‚≠ï</div>
                <div id="player-o-name">Player O</div>
            </div>
        </div>

        <!-- Game Board -->
        <div class="mega-board" id="mega-board">
            <!-- Will be generated by JavaScript -->
        </div>

        <!-- Controls -->
        <div class="controls">
            <button class="control-btn new-game-btn" onclick="resetGame()">
                üéÆ New Game
            </button>
            <button class="control-btn rules-btn" onclick="showRules()">
                üìã Rules
            </button>
        </div>
    </div>

    <!-- Rules Modal -->
    <div class="modal" id="rules-modal">
        <div class="modal-content">
            <button class="modal-close" onclick="hideRules()">&times;</button>
            <h2>üéØ Mega Tic-Tac-Toe Rules</h2>
            
            <h3>üéÆ How to Play</h3>
            <ol>
                <li><strong>9 Mini-Boards:</strong> The game consists of 9 mini tic-tac-toe boards arranged in a 3√ó3 grid.</li>
                <li><strong>Strategic Movement:</strong> Your move determines which mini-board your opponent must play in next.</li>
                <li><strong>Win Mini-Boards:</strong> Get 3 in a row within a mini-board to claim it.</li>
                <li><strong>Win the Game:</strong> Get 3 mini-boards in a row to win the mega game!</li>
            </ol>

            <h3>üéØ Strategy Tips</h3>
            <ul>
                <li><strong>Control the Flow:</strong> Think about which mini-board you're sending your opponent to.</li>
                <li><strong>Multiple Threats:</strong> Try to set up multiple ways to win simultaneously.</li>
                <li><strong>Defense:</strong> Block your opponent from winning mini-boards when possible.</li>
                <li><strong>Center Control:</strong> The center mini-board is often the most valuable.</li>
            </ul>

            <h3>ü§ñ AI Modes</h3>
            <ul>
                <li><strong>Easy:</strong> Random moves, great for beginners</li>
                <li><strong>Medium:</strong> Strategic blocking and winning moves</li>
                <li><strong>Hard:</strong> Advanced lookahead and tactical positioning</li>
            </ul>
        </div>
    </div>

    <script>
        // Game state
        let currentPlayer = 'X';
        let gameMode = 'human'; // 'human' or 'ai'
        let aiDifficulty = 'medium';
        let gameState = 'playing';
        let activeMiniBoard = null;
        let isFirstMove = true;
        let isAiThinking = false;

        // Game boards
        let megaBoard = Array(9).fill(null);
        let miniBoards = Array(9).fill(null).map(() => Array(9).fill(null));

        // Initialize game
        function initGame() {
            createBoard();
            updateDisplay();
        }

        function createBoard() {
            const megaBoardElement = document.getElementById('mega-board');
            megaBoardElement.innerHTML = '';

            for (let boardIndex = 0; boardIndex < 9; boardIndex++) {
                const miniBoard = document.createElement('div');
                miniBoard.className = 'mini-board';
                miniBoard.dataset.boardIndex = boardIndex;

                for (let cellIndex = 0; cellIndex < 9; cellIndex++) {
                    const cell = document.createElement('button');
                    cell.className = 'cell';
                    cell.dataset.boardIndex = boardIndex;
                    cell.dataset.cellIndex = cellIndex;
                    cell.onclick = () => handleCellClick(boardIndex, cellIndex);
                    miniBoard.appendChild(cell);
                }

                megaBoardElement.appendChild(miniBoard);
            }
        }

        function setGameMode(mode) {
            gameMode = mode;
            
            // Update buttons
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');

            // Show/hide AI settings
            const aiSettings = document.getElementById('ai-settings');
            if (mode === 'ai') {
                aiSettings.classList.add('show');
            } else {
                aiSettings.classList.remove('show');
            }

            // Update player names
            updatePlayerNames();
            
            // Reset game
            resetGame();
        }

        function setDifficulty(difficulty) {
            aiDifficulty = difficulty;
            
            // Update buttons
            document.querySelectorAll('.difficulty-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');
        }

        function updatePlayerNames() {
            const playerXName = document.getElementById('player-x-name');
            const playerOName = document.getElementById('player-o-name');
            
            if (gameMode === 'ai') {
                playerXName.textContent = 'You';
                playerOName.textContent = 'AI';
            } else {
                playerXName.textContent = 'Player X';
                playerOName.textContent = 'Player O';
            }
        }

        function handleCellClick(boardIndex, cellIndex) {
            if (gameState !== 'playing' || isAiThinking) return;
            
            // In AI mode, only allow human player to click
            if (gameMode === 'ai' && currentPlayer === 'O') return;

            if (!isValidMove(boardIndex, cellIndex)) return;

            makeMove(boardIndex, cellIndex);
            
            if (checkGameEnd()) return;

            switchPlayer();
            updateDisplay();

            // AI move
            if (gameMode === 'ai' && currentPlayer === 'O') {
                setTimeout(makeAiMove, 500);
            }
        }

        function isValidMove(boardIndex, cellIndex) {
            // Check if cell is occupied
            if (miniBoards[boardIndex][cellIndex] !== null) return false;
            
            // Check if mini-board is won
            if (megaBoard[boardIndex] !== null) return false;
            
            // Check if this is the correct mini-board
            if (activeMiniBoard !== null && activeMiniBoard !== boardIndex) return false;
            
            return true;
        }

        function makeMove(boardIndex, cellIndex) {
            // Update game state
            miniBoards[boardIndex][cellIndex] = currentPlayer;
            
            // Update visual
            const cell = document.querySelector(`[data-board-index="${boardIndex}"][data-cell-index="${cellIndex}"]`);
            cell.textContent = currentPlayer;
            cell.classList.add(currentPlayer.toLowerCase());
            cell.classList.add('disabled');
            
            isFirstMove = false;
        }

        function checkGameEnd() {
            // Check for mini-board win
            for (let i = 0; i < 9; i++) {
                if (megaBoard[i] === null) {
                    const winner = checkMiniboardWin(i);
                    if (winner) {
                        claimMiniBoard(i, winner);
                    }
                }
            }

            // Check for mega-board win
            const megaWinner = checkMegaboardWin();
            if (megaWinner) {
                endGame(megaWinner);
                return true;
            }

            // Check for draw
            if (checkDraw()) {
                endGame('draw');
                return true;
            }

            return false;
        }

        function checkMiniboardWin(boardIndex) {
            const board = miniBoards[boardIndex];
            const winPatterns = [
                [0, 1, 2], [3, 4, 5], [6, 7, 8], // rows
                [0, 3, 6], [1, 4, 7], [2, 5, 8], // columns
                [0, 4, 8], [2, 4, 6] // diagonals
            ];

            for (const pattern of winPatterns) {
                const [a, b, c] = pattern;
                if (board[a] && board[a] === board[b] && board[a] === board[c]) {
                    return board[a];
                }
            }
            return null;
        }

        function checkMegaboardWin() {
            const winPatterns = [
                [0, 1, 2], [3, 4, 5], [6, 7, 8], // rows
                [0, 3, 6], [1, 4, 7], [2, 5, 8], // columns
                [0, 4, 8], [2, 4, 6] // diagonals
            ];

            for (const pattern of winPatterns) {
                const [a, b, c] = pattern;
                if (megaBoard[a] && megaBoard[a] === megaBoard[b] && megaBoard[a] === megaBoard[c]) {
                    return megaBoard[a];
                }
            }
            return null;
        }

        function claimMiniBoard(boardIndex, winner) {
            megaBoard[boardIndex] = winner;
            
            const miniBoard = document.querySelector(`[data-board-index="${boardIndex}"]`);
            miniBoard.classList.add('won');
            miniBoard.dataset.winner = winner;
            
            // Disable all cells in this mini-board
            const cells = miniBoard.querySelectorAll('.cell');
            cells.forEach(cell => cell.classList.add('disabled'));
        }

        function checkDraw() {
            for (let i = 0; i < 9; i++) {
                if (megaBoard[i] === null && miniBoards[i].includes(null)) {
                    return false;
                }
            }
            return true;
        }

        function switchPlayer() {
            currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
            
            // Set next active mini-board
            const lastMove = getLastMove();
            if (lastMove && megaBoard[lastMove.cellIndex] === null && miniBoards[lastMove.cellIndex].includes(null)) {
                activeMiniBoard = lastMove.cellIndex;
            } else {
                activeMiniBoard = null; // Free choice
            }
        }

        function getLastMove() {
            // Find the last move made
            for (let boardIndex = 0; boardIndex < 9; boardIndex++) {
                for (let cellIndex = 0; cellIndex < 9; cellIndex++) {
                    const cell = document.querySelector(`[data-board-index="${boardIndex}"][data-cell-index="${cellIndex}"]`);
                    if (cell.textContent && !cell.dataset.processed) {
                        cell.dataset.processed = 'true';
                        return { boardIndex, cellIndex };
                    }
                }
            }
            return null;
        }

        function updateDisplay() {
            // Update player indicators
            document.getElementById('player-x').classList.toggle('current', currentPlayer === 'X');
            document.getElementById('player-o').classList.toggle('current', currentPlayer === 'O');

            // Update active mini-boards
            document.querySelectorAll('.mini-board').forEach((board, index) => {
                board.classList.remove('active');
                if (activeMiniBoard === null) {
                    // Free choice - highlight available boards
                    if (megaBoard[index] === null && miniBoards[index].includes(null)) {
                        board.classList.add('active');
                    }
                } else if (activeMiniBoard === index) {
                    board.classList.add('active');
                }
            });

            // Update game status
            updateGameStatus();
        }

        function updateGameStatus() {
            const statusElement = document.getElementById('game-status');
            
            if (gameState === 'playing') {
                if (isAiThinking) {
                    statusElement.textContent = 'ü§ñ AI is thinking...';
                } else if (isFirstMove) {
                    statusElement.textContent = 'Choose any cell to start your mega battle!';
                } else if (activeMiniBoard !== null) {
                    if (gameMode === 'ai') {
                        statusElement.textContent = currentPlayer === 'X' 
                            ? `üéØ Your turn - Play in mini-board ${activeMiniBoard + 1}`
                            : `ü§ñ AI's turn - Playing in mini-board ${activeMiniBoard + 1}`;
                    } else {
                        statusElement.textContent = `üéÆ Player ${currentPlayer} must play in mini-board ${activeMiniBoard + 1}`;
                    }
                } else {
                    if (gameMode === 'ai') {
                        statusElement.textContent = currentPlayer === 'X' 
                            ? 'üéØ Your turn - Free choice!'
                            : 'ü§ñ AI\'s turn - Free choice!';
                    } else {
                        statusElement.textContent = `üéÆ Player ${currentPlayer}'s turn - Free choice!`;
                    }
                }
            } else if (gameState === 'won') {
                if (gameMode === 'ai') {
                    statusElement.textContent = megaBoard.winner === 'X' 
                        ? 'üéâ You win! Amazing!' 
                        : 'ü§ñ AI wins! Try again!';
                } else {
                    statusElement.textContent = `üéâ Player ${megaBoard.winner} wins the mega game!`;
                }
            } else if (gameState === 'draw') {
                statusElement.textContent = 'ü§ù Game ended in a draw!';
            }
        }

        function endGame(result) {
            gameState = result === 'draw' ? 'draw' : 'won';
            megaBoard.winner = result === 'draw' ? null : result;
            
            // Disable all cells
            document.querySelectorAll('.cell').forEach(cell => {
                cell.classList.add('disabled');
            });

            // Remove active states
            document.querySelectorAll('.mini-board').forEach(board => {
                board.classList.remove('active');
            });

            updateGameStatus();

            // Show result
            setTimeout(() => {
                if (result === 'draw') {
                    alert('ü§ù Game ended in a draw! Well played!');
                } else if (gameMode === 'ai') {
                    if (result === 'X') {
                        alert('üéâ Congratulations! You beat the AI! üéâ');
                    } else {
                        alert('ü§ñ AI wins this round! Try again?');
                    }
                } else {
                    alert(`üéâ Congratulations Player ${result}! You won! üéâ`);
                }
            }, 500);
        }

        function makeAiMove() {
            if (gameState !== 'playing' || currentPlayer !== 'O') return;

            isAiThinking = true;
            updateGameStatus();

            setTimeout(() => {
                const move = calculateAiMove();
                if (move) {
                    makeMove(move.boardIndex, move.cellIndex);
                    if (!checkGameEnd()) {
                        switchPlayer();
                        updateDisplay();
                    }
                }
                isAiThinking = false;
                updateGameStatus();
            }, 800);
        }

        function calculateAiMove() {
            const validMoves = getValidMoves();
            if (validMoves.length === 0) return null;

            switch (aiDifficulty) {
                case 'easy':
                    return validMoves[Math.floor(Math.random() * validMoves.length)];
                case 'medium':
                    return getMediumMove(validMoves);
                case 'hard':
                    return getHardMove(validMoves);
                default:
                    return validMoves[Math.floor(Math.random() * validMoves.length)];
            }
        }

        function getValidMoves() {
            const moves = [];
            for (let boardIndex = 0; boardIndex < 9; boardIndex++) {
                if (megaBoard[boardIndex] !== null) continue;
                if (activeMiniBoard !== null && activeMiniBoard !== boardIndex) continue;

                for (let cellIndex = 0; cellIndex < 9; cellIndex++) {
                    if (miniBoards[boardIndex][cellIndex] === null) {
                        moves.push({ boardIndex, cellIndex });
                    }
                }
            }
            return moves;
        }

        function getMediumMove(validMoves) {
            // Try to win a mini-board
            const winMove = findWinningMove(validMoves, 'O');
            if (winMove) return winMove;

            // Block human from winning
            const blockMove = findWinningMove(validMoves, 'X');
            if (blockMove) return blockMove;

            // Random move
            return validMoves[Math.floor(Math.random() * validMoves.length)];
        }

        function getHardMove(validMoves) {
            // Try to win the mega game
            const megaWin = findMegaWinningMove(validMoves);
            if (megaWin) return megaWin;

            // Block human from winning mega game
            const megaBlock = findMegaBlockingMove(validMoves);
            if (megaBlock) return megaBlock;

            // Try to win a mini-board
            const winMove = findWinningMove(validMoves, 'O');
            if (winMove) return winMove;

            // Block human from winning
            const blockMove = findWinningMove(validMoves, 'X');
            if (blockMove) return blockMove;

            // Strategic move (center preference)
            const strategicMove = getStrategicMove(validMoves);
            if (strategicMove) return strategicMove;

            // Random move
            return validMoves[Math.floor(Math.random() * validMoves.length)];
        }

        function findWinningMove(validMoves, player) {
            for (const move of validMoves) {
                // Simulate move
                miniBoards[move.boardIndex][move.cellIndex] = player;
                const isWin = checkMiniboardWin(move.boardIndex) === player;
                // Undo move
                miniBoards[move.boardIndex][move.cellIndex] = null;
                
                if (isWin) return move;
            }
            return null;
        }

        function findMegaWinningMove(validMoves) {
            for (const move of validMoves) {
                // Simulate winning the mini-board
                const originalWinner = megaBoard[move.boardIndex];
                megaBoard[move.boardIndex] = 'O';
                const isWin = checkMegaboardWin() === 'O';
                megaBoard[move.boardIndex] = originalWinner;
                
                if (isWin) {
                    // Check if this move actually wins the mini-board
                    miniBoards[move.boardIndex][move.cellIndex] = 'O';
                    const winsBoard = checkMiniboardWin(move.boardIndex) === 'O';
                    miniBoards[move.boardIndex][move.cellIndex] = null;
                    
                    if (winsBoard) return move;
                }
            }
            return null;
        }

        function findMegaBlockingMove(validMoves) {
            for (const move of validMoves) {
                // Simulate human winning the mini-board
                const originalWinner = megaBoard[move.boardIndex];
                megaBoard[move.boardIndex] = 'X';
                const humanWins = checkMegaboardWin() === 'X';
                megaBoard[move.boardIndex] = originalWinner;
                
                if (humanWins) {
                    // Check if human could actually win this mini-board
                    const humanCanWin = findWinningMove([move], 'X');
                    if (humanCanWin) return move;
                }
            }
            return null;
        }

        function getStrategicMove(validMoves) {
            // Prefer center cells and corners
            const priorities = [4, 0, 2, 6, 8, 1, 3, 5, 7];
            
            for (const cellIndex of priorities) {
                const strategicMoves = validMoves.filter(move => move.cellIndex === cellIndex);
                if (strategicMoves.length > 0) {
                    return strategicMoves[Math.floor(Math.random() * strategicMoves.length)];
                }
            }
            return null;
        }

        function resetGame() {
            currentPlayer = 'X';
            gameState = 'playing';
            activeMiniBoard = null;
            isFirstMove = true;
            isAiThinking = false;
            
            megaBoard = Array(9).fill(null);
            miniBoards = Array(9).fill(null).map(() => Array(9).fill(null));
            
            createBoard();
            updateDisplay();
        }

        function showRules() {
            document.getElementById('rules-modal').style.display = 'flex';
        }

        function hideRules() {
            document.getElementById('rules-modal').style.display = 'none';
        }

        // Close modal on outside click
        document.getElementById('rules-modal').addEventListener('click', function(e) {
            if (e.target === this) {
                hideRules();
            }
        });

        // Initialize game when page loads
        window.addEventListener('load', initGame);
    </script>
</body>
</html>
